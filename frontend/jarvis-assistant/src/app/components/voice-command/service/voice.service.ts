import { Injectable } from '@angular/core';
import { Observable, Subject, BehaviorSubject} from 'rxjs';
import { HttpClient } from '@angular/common/http';
import emojiRegex from 'emoji-regex';

// Add SpeechRecognition type for TypeScript
declare global {
  interface Window {
    webkitSpeechRecognition: any;
    SpeechRecognition: any;
  }
}
type SpeechRecognition = typeof window.SpeechRecognition;

export interface AskResponse {
    response: string;
}

@Injectable({
  providedIn: 'root',
})
export class VoiceService {
  private synth: SpeechSynthesis | null = typeof window !== 'undefined' ? window.speechSynthesis : null;// Synth√®se vocale
  private recognition: SpeechRecognition | null = null;// Reconnaissance vocale
  isListening = false; // Pour √©viter les d√©marrages multiples
  private voiceJarvis: SpeechSynthesisVoice | null = null;// Voix s√©lectionn√©e pour Jarvis

  public speaking$ = new BehaviorSubject<boolean>(false);
  private isStopped = false;

  private apiUrl = 'http://localhost:8000/ask';  // adapte l‚ÄôURL si besoin
  
  lectureTermineIA=true;
  
  
  constructor(private http : HttpClient) {
     // üîà V√©rifie si la synth√®se vocale est disponible
    
    console.log('********************* constructor VoiceService');
     if (!this.synth) {
      console.warn('üß† speechSynthesis non disponible dans cet environnement');
      return;
    }
// üîÅ Essaie de r√©cup√©rer les voix imm√©diatement
    const voices = this.synth.getVoices();
    if (voices.length) {
      this.setVoice(voices);// Si disponibles, s√©lectionne une voix
    } else {
        this.synth.onvoiceschanged = () => {
        if (!this.synth) return;
        const loadedVoices = this.synth.getVoices();
        if (loadedVoices) this.setVoice(loadedVoices);
      };
    }


  }

  ask(message: string): Observable<AskResponse> {
      console.log('********************* ask VoiceService');
    console.log(`üîä message ask :  ${message} `);
    return this.http.post<AskResponse>(this.apiUrl, { message });
  }
  /**
   * üîß S√©lectionne la voix √† utiliser pour Jarvis
   */
  private setVoice(voices: SpeechSynthesisVoice[]) {
    console.log('********************* setVoice VoiceService');
    // üéØ Cherche une voix fran√ßaise avec un nom masculin ou √©vocateur
    this.voiceJarvis = voices.find(voice =>
      voice.lang === 'fr-FR' &&
      /paul|thomas|male|homme|jarvis/i.test(voice.name)
    )
    // üîÑ Sinon, prend n‚Äôimporte quelle voix fran√ßaise
    ?? voices.find(voice => voice.lang === 'fr-FR')
    // üõë Sinon, aucune voix
    ?? null;

    if (this.voiceJarvis) {
      console.log(`‚úÖ Voix Jarvis s√©lectionn√©e : ${this.voiceJarvis.name}`);
    } else {
      console.warn('‚ö†Ô∏è Aucune voix fran√ßaise disponible pour Jarvis');
    }

    // üó£Ô∏è Pour debug : liste compl√®te
    console.table(
      voices.map(v => ({
        nom: v.name,
        langue: v.lang,
        d√©faut: v.default,
      }))
    );
}


// Nettoyage texte : enl√®ve markdown, emojis, symboles
 cleanResponse(text: string): string {
  console.log('********************* cleanResponse VoiceService');
  // Supprime le gras et l'italique Markdown
  text = text.replace(/\*\*.*?\*\*/g, '');
  text = text.replace(/\*.*?\*/g, '');

  // Supprime certains symboles (*, #, ‚Ä¢, -)
  text = text.replace(/[\*#‚Ä¢\-]/g, '');

  // Supprime les emojis
  const regex = emojiRegex();
  text = text.replace(regex, '');

  // ‚úÖ Supprime les caract√®res non autoris√©s sauf lettres accentu√©es et ponctuation basique
  text = text.replace(/[^\p{L}\p{N}\s.,!?'"()\-]+/gu, '');

  // R√©duit les espaces multiples
  text = text.replace(/\s{2,}/g, ' ');

  return text.trim();
}

  
  

  // Initialise la reconnaissance vocale continue
  initializeRecognition(onCommand: (text: string) => void): void {
    console.log('********************* initializeRecognition VoiceService');
    
    const SpeechRecognition =

      (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;

    if (!SpeechRecognition) {
      console.warn('üé§ Reconnaissance vocale non disponible');
      return;
    }

    this.recognition = new SpeechRecognition();
    this.recognition.lang = 'fr-FR';
    this.recognition.continuous = true;// √âcoute en continu
    this.recognition.interimResults = false;// Pas de r√©sultats interm√©diaires
    
      this.recognition.onresult = (event: any) => {
        console.log('********************* initializeRecognition recognition.onresult VoiceService');
        if(this.isListening){
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            console.log('üß† Commande reconnue :', transcript);
            onCommand(transcript);
            this.isListening=false;
        }
      }
    
    
    this.recognition.onerror = (event: any) => {
      console.log('********************* initializeRecognition recognition.onerror VoiceService');
      console.error('‚ùå Erreur vocale :', event.error);
    };

    this.recognition.onend = () => {
      console.log('********************* initializeRecognition recognition.onend VoiceService');
      console.log('üîÅ Session termin√©e ‚Äì relancement...');
      //setTimeout(() => this.recognition?.start(), 7500);
   

    };
 }

 

  // Lit vocalement un texte avec voix Jarvis et animations
  speakForModule(text: string, domain: string, assistant: 'jarvis'): void {
    this.isListening=false;
      console.log('********************* speakForModule VoiceService');
    if (!this.synth) return;

    if (!this.voiceJarvis) {
      console.warn('üîÅ Voix non charg√©e, r√©essai dans 2 secondes...');
      setTimeout(() => this.speakForModule(text, domain, assistant), 2000);
      return;
    }

    const utter = new SpeechSynthesisUtterance(text);
    utter.voice = this.voiceJarvis;
    utter.lang = 'fr-FR';
    utter.rate = assistant === 'jarvis' ? 0.9 : 1.2;
    utter.pitch = assistant === 'jarvis' ? 0.75 : 0.5;
    utter.volume = 1;

    utter.onstart = () => {
      this.stopListening(); // stoppe l'√©coute
      console.log('********************* speakForModule utter.onstart VoiceService');
    
      this.speaking$.next(true);
      console.log(`üîä Lecture par ${assistant} dans le domaine ${domain}: ${text}`);
    };

    utter.onend = () => {
      console.log('********************* speakForModule utter.onend VoiceService');
     console.log(`‚úÖ Lecture termin√©e par ${assistant}`);
     
     setTimeout(() => this.startListening(), 500); // üëà Red√©marre l'√©coute avec d√©lai
    };

    utter.onerror = (event) => {
      console.log('********************* speakForModule utter.onerror VoiceService');
        console.error('‚ö†Ô∏è Erreur de lecture :', (event as any).error);
    };

    this.synth.speak(utter);
    
      console.log('********************* speakForModule Fin VoiceService');
  }
  
// pour permettre d'interrompte jarvis quand il parle on decoupe en phrases
speakInChunks(text: string, voiceType: string = 'jarvis'): void {
  console.log('********************* speakInChunks VoiceService');
  if (!text || this.synth?.speaking) return; // üîí Ne rien faire si d√©j√† en train de parler

  // üß© D√©coupe le texte en phrases (bas√© sur ponctuation)
  const sentences = text
    .split(/[\.\!\?]/) // S√©pare sur les points, points d'exclamation, etc.
    .map(s => s.trim()) // Supprime les espaces inutiles
    .filter(s => s.length > 0); // Ignore les phrases vides

  let index = 0; // üìç Position actuelle dans le tableau de phrases

  const speakNext = () => {
    if (index >= sentences.length || this.isStopped) {
      // ‚úÖ Fin du discours ou interruption
      this.speaking$.next(false);
      this.isStopped = false;
      return;
    }

    const utterance = new SpeechSynthesisUtterance(sentences[index]);

    // üéôÔ∏è S√©lectionne la voix selon le type
    utterance.voice = this.voiceJarvis;
    utterance.lang = 'fr-FR';
    utterance.rate = voiceType === 'jarvis' ? 0.9 : 1;
    utterance.pitch = voiceType === 'jarvis' ? 0.75 : 1;
    utterance.volume = 1;

    // üîÑ D√©clenche animation ou √©tat "parle"
    utterance.onstart = () => {
       console.log('********************* speakInChunks  utterance.onstart VoiceService');
      this.speaking$.next(true);
      console.log(`üó£Ô∏è Jarvis dit : ${sentences[index]}`);
    };

    // ‚è≠Ô∏è Quand la phrase est termin√©e, passe √† la suivante
    utterance.onend = () => {
      console.log('********************* speakInChunks  utterance.onend VoiceService');
      this.speaking$.next(false);
      index++;
      setTimeout(() => speakNext(), 300); // ‚è±Ô∏è Petite pause entre les phrases
    };

    // ‚ö†Ô∏è Gestion des erreurs
    utterance.onerror = (event) => {
      console.error('‚ö†Ô∏è Erreur de lecture :', event.error);
      this.isStopped = true;
    };

    // üîä Lance la lecture
    this.synth?.speak(utterance);
  };

  // üöÄ D√©marre la lecture
  //speakNext();
}


  // D√©marre l'√©coute (si besoin)
  startListening(): void {
    console.log('********************* startListening VoiceService');
  if (!this.recognition) {

    console.warn('‚ùå Recognition non initialis√©e. Appelle initializeRecognition() d‚Äôabord.');
    return;
  }

  if (this.isListening) {
    console.log('‚è≥ Jarvis √©coute d√©j√†.');
    return;
  }

  try {
    this.recognition.start();
    this.isListening = true;
    console.log('üéß Jarvis √©coute...');
  } catch (error: any) {
    if (error.name === 'InvalidStateError') {
      console.warn('‚ö†Ô∏è Recognition d√©j√† en cours :', error.message);
    } else {
      console.error('‚ùå Erreur inattendue dans startListening :', error);
    }
    this.isListening = false;
  }
}
stopListening(): void {
  console.log('********************* stopListening VoiceService');
  if (this.recognition && this.isListening) {
    this.recognition.stop();
    this.isStopped = true;
    this.isListening = false;
  }
}

stopSpeaking(): void {
  console.log('********************* stopSpeaking VoiceService');
  // ‚úÖ V√©rifie que le synth√©tiseur est disponible et qu'une lecture est en cours
  if (this.synth && this.synth.speaking) {
    this.isStopped = true;
    this.synth.cancel(); // üõë Arr√™te imm√©diatement toute lecture vocale
    this.speaking$.next(false);   // üîÑ Met √† jour l'√©tat observable
    console.log('üõë Lecture vocale arr√™t√©e par l‚Äôutilisateur');
  }
}

 // Transforme les emojis en mots lisibles
describeEmojis(text: string): string {
  const emojiMap: { [emoji: string]: string } = {
    'üòÄ': 'souriant',
    'üòÑ': 'sourire',
    'üòÇ': 'rire',
    'üò≠': 'pleure',
    '‚ù§Ô∏è': 'coeur',
    'üëç': 'pouce lev√©',
    'üî•': 'feu',
    'üí°': 'id√©e',
    'üéâ': 'f√™te',
    'ü§ñ': 'robot',
    // ajoute ici ceux que tu veux
  };

  return text.replace(emojiRegex(), (match) => {
    return emojiMap[match] ? ` ${emojiMap[match]} ` : '';
  });
}

toggleSpeaking(text: string, voiceType: string = 'jarvis'): void {
  console.log('********************* toggleSpeaking VoiceService');
  if (this.synth?.speaking) {
    this.stopSpeaking(); // üõë Interrompt la lecture
  } else {
   this.startListening() // üîä D√©marre la lecture
  }
}


}



